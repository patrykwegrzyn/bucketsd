{"version":3,"sources":["../src/index.ts","../src/util.ts"],"sourcesContent":["import {\n  KafkaConsumer,\n  ConsumerGlobalConfig,\n  ConsumerTopicConfig,\n  Producer,\n  ProducerGlobalConfig,\n  ProducerTopicConfig,\n  Assignment,\n  Message,\n  LibrdKafkaError,\n  AdminClient,\n  CODES,\n  NewTopic,\n} from \"@confluentinc/kafka-javascript\";\n\nimport { RootDatabaseOptions, asBinary } from \"lmdb\";\nimport { Buffer } from \"buffer\";\nimport { Store } from \"buckets\";\nimport { once } from \"events\";\n\nimport { getAssigments, getMetadata } from \"./util\";\n\ntype Options = {\n  appId: string;\n  brokers: string[];\n  store?: RootDatabaseOptions;\n  consumer?: {\n    global: ConsumerGlobalConfig;\n    topic?: ConsumerTopicConfig;\n  };\n  producer?: {\n    global: ProducerGlobalConfig;\n    topic?: ProducerTopicConfig;\n  };\n  createTopicOptions?: NewTopic;\n};\n\nexport class Bucketsd {\n  topic: string;\n  appId: string;\n  consumer: KafkaConsumer;\n  producer: Producer;\n  initialized = false;\n  store: Store;\n  watermarks = new Map<number, number>();\n  topicOffsets = new Map<number, number>();\n  createTopicOptions?: NewTopic;\n\n  constructor(options: Options) {\n    const { createTopicOptions, appId, brokers, store, consumer, producer } =\n      options;\n    this.topic = createTopicOptions ? createTopicOptions.topic : `${appId}.kv`;\n    this.appId = appId;\n    this.createTopicOptions = createTopicOptions;\n\n    this.store = new Store(`db/${appId}`, { cache: false, ...store });\n    this.store.on(\"change\", (ev) => this.handleStoreChange(ev));\n\n    const brokerList = Array.isArray(brokers)\n      ? brokers.join(\",\")\n      : \"localhost:19092\";\n\n    this.consumer = new KafkaConsumer(\n      {\n        \"group.id\": \"kv\",\n        \"bootstrap.servers\": brokerList,\n        \"enable.auto.commit\": false,\n        \"enable.auto.offset.store\": false,\n        ...consumer?.global,\n      },\n      { \"auto.offset.reset\": \"beginning\", ...(consumer?.topic || {}) }\n    );\n\n    this.producer = new Producer(\n      {\n        \"bootstrap.servers\": brokerList,\n        ...producer?.global,\n      },\n      { ...producer?.topic }\n    );\n    this.producer.setPollInterval(100);\n  }\n\n  private handleStoreChange(ev: {\n    op: string;\n    bucket: string;\n    id: string;\n    value: string | Buffer;\n    ttl?: string;\n  }) {\n    const { op, bucket, id, value, ttl } = ev;\n\n    // console.log(value, JSON.parse(value as string));\n\n    // Construct headers array\n    const headers = [];\n    if (op) headers.push({ op });\n    if (bucket) headers.push({ bucket });\n    if (ttl) headers.push({ ttl });\n\n    const messageValue =\n      op === \"remove\"\n        ? null\n        : Buffer.isBuffer(value)\n        ? value\n        : Buffer.from(value);\n    try {\n      this.producer.produce(\n        this.topic,\n        null,\n        messageValue,\n        id,\n        Date.now(),\n        undefined,\n        headers\n      );\n    } catch (err: unknown) {\n      const error = err as LibrdKafkaError;\n\n      if (CODES.ERRORS.ERR__QUEUE_FULL === error.code) {\n        console.log(\"Queue full, re-buffering message\");\n        this.producer.poll();\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  private queryWatermark(partition: number): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.consumer.queryWatermarkOffsets(\n        this.topic,\n        partition,\n        5000,\n        (err, offsets) => {\n          if (err) return reject(err);\n          console.log(\"queryWatermarkOffsets\", { partition, offsets });\n          this.watermarks.set(partition, Number(offsets.highOffset));\n          this.topicOffsets.set(partition, -1);\n          resolve();\n        }\n      );\n    });\n  }\n\n  protected async setupPartitionStatus(assignments: Assignment[]) {\n    await Promise.all(\n      assignments.map(({ partition }) => this.queryWatermark(partition))\n    );\n    console.log(\"Partition status initialized:\", this.watermarks);\n  }\n\n  async start() {\n    this.consumer.setDefaultConsumeTimeout(1000);\n    this.consumer.connect();\n    this.producer.connect();\n\n    await Promise.all([\n      once(this.consumer, \"ready\"),\n      once(this.producer, \"ready\"),\n    ]);\n    const admin = AdminClient.createFrom(this.consumer);\n\n    admin.createTopic(\n      {\n        num_partitions: 5,\n        replication_factor: 3,\n        config: {\n          \"segment.ms\": \"300000\",\n          \"segment.bytes\": \"102400\",\n          \"cleanup.policy\": \"compact\",\n        },\n        ...{ ...this.createTopicOptions, topic: this.topic },\n      },\n      async (err) => {\n        if (err && err.code !== CODES.ERRORS.ERR_TOPIC_ALREADY_EXISTS) {\n          throw err;\n        }\n\n        const metadata = await getMetadata(this.consumer, {});\n        const assignments = getAssigments(metadata, [this.topic]);\n        this.consumer.assign(assignments);\n        await this.setupPartitionStatus(assignments);\n\n        this.consumer.consume();\n        this.consumer.on(\"data\", (message) => this.handleConsumerData(message));\n      }\n    );\n\n    await this.waitUntilCaughtUp();\n  }\n\n  private handleConsumerData(message: Message) {\n    this.topicOffsets.set(message.partition, message.offset);\n\n    const headers = message.headers?.reduce<Record<string, string>>(\n      (obj, h) => {\n        const key = Object.keys(h)[0];\n        obj[key] = h[key].toString();\n        return obj;\n      },\n      {}\n    );\n\n    if (message.key && headers?.bucket && headers?.op) {\n      const kv = this.store.bucket(headers.bucket);\n      if (headers.op === \"put\" && message.value) {\n        kv.put(message.key.toString(), asBinary(message.value), {\n          quiet: true,\n        });\n      } else {\n        kv.remove(message.key.toString(), { quiet: true });\n      }\n    }\n  }\n\n  private waitUntilCaughtUp(): Promise<void> {\n    return new Promise((resolve) => {\n      const interval = setInterval(() => {\n        if (this.hasCaughtUp()) {\n          clearInterval(interval);\n          console.log(\"All partitions caught up. KV is ready.\");\n          this.initialized = true;\n          resolve();\n        }\n      }, 1000);\n    });\n  }\n\n  hasCaughtUp() {\n    return Array.from(this.watermarks.entries()).every(\n      ([partition, watermark]) => {\n        const current = this.topicOffsets.get(partition);\n        return current !== undefined && current >= watermark - 1;\n      }\n    );\n  }\n\n  async stop() {\n    this.consumer.unsubscribe();\n    this.consumer.pause(this.consumer.assignments());\n\n    this.producer.flush(5000, (err: LibrdKafkaError) => {\n      console.log(err);\n      this.producer.disconnect();\n      this.consumer.disconnect();\n    });\n\n    await Promise.all(\n      [this.consumer, this.producer].map((client) =>\n        once(client, \"disconnected\")\n      )\n    );\n  }\n}\n","import {\n  Assignment,\n  KafkaConsumer,\n  Metadata,\n  MetadataOptions,\n  SubscribeTopicList,\n} from \"@confluentinc/kafka-javascript\";\n\nexport function getWatermarkOffsets(\n  consumer: KafkaConsumer,\n  topic: string,\n  partitions: number[],\n  timeout = 1000\n) {\n  const queries = partitions.map((partition) => {\n    return new Promise((resolve, reject) => {\n      consumer.queryWatermarkOffsets(\n        topic,\n        partition,\n        timeout,\n        (err, offsets) => {\n          if (err) {\n            return reject(err);\n          }\n          resolve({ partition, highOffset: offsets.highOffset });\n        }\n      );\n    });\n  });\n\n  return Promise.all(queries);\n}\n\nexport function getTopicsMetadata(\n  metadata: Metadata,\n  topics: SubscribeTopicList\n) {\n  return metadata.topics.filter((metaTopic) => {\n    return topics.some((topicFilter) => {\n      if (typeof topicFilter === \"string\") {\n        return metaTopic.name === topicFilter;\n      } else if (topicFilter instanceof RegExp) {\n        return topicFilter.test(metaTopic.name);\n      }\n      return false;\n    });\n  });\n}\n\nexport function getMetadata(\n  consumer: KafkaConsumer,\n  options: MetadataOptions\n): Promise<Metadata> {\n  return new Promise((resolve, reject) =>\n    consumer.getMetadata(options, (err, metadata) =>\n      err ? reject(err) : resolve(metadata)\n    )\n  );\n}\n\nexport function getAssigments(\n  metadata: Metadata,\n  topics: SubscribeTopicList\n): Assignment[] {\n  const assigments = getTopicsMetadata(metadata, topics).flatMap((metaTopic) =>\n    metaTopic.partitions.map((partition) => ({\n      topic: metaTopic.name,\n      partition: partition.id,\n      offset: 0, // Change this offset if you want to start elsewhere\n    }))\n  );\n\n  return assigments;\n}\n"],"mappings":"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","names":[]}