{"version":3,"sources":["../src/index.ts","../src/util.ts"],"sourcesContent":["import {\n  KafkaConsumer,\n  ConsumerGlobalConfig,\n  ConsumerTopicConfig,\n  Producer,\n  ProducerGlobalConfig,\n  ProducerTopicConfig,\n  Assignment,\n  Message,\n  LibrdKafkaError,\n  AdminClient,\n  CODES,\n  NewTopic,\n} from \"@confluentinc/kafka-javascript\";\n\nimport { RootDatabaseOptions } from \"lmdbx\";\nimport { Buffer } from \"buffer\";\nimport { Store } from \"buckets\";\nimport { once } from \"events\";\n\nimport { getAssigments, getMetadata } from \"./util\";\n\ntype Options = {\n  appId: string;\n  brokers: string[];\n  store?: RootDatabaseOptions;\n  consumer?: {\n    global: ConsumerGlobalConfig;\n    topic?: ConsumerTopicConfig;\n  };\n  producer?: {\n    global: ProducerGlobalConfig;\n    topic?: ProducerTopicConfig;\n  };\n  createTopicOptions?: NewTopic;\n};\n\nexport class Bucketsd {\n  topic: string;\n  appId: string;\n  consumer: KafkaConsumer;\n  producer: Producer;\n  initialized = false;\n  store: Store;\n  watermarks = new Map<number, number>();\n  topicOffsets = new Map<number, number>();\n  createTopicOptions?: NewTopic;\n\n  constructor(options: Options) {\n    const { createTopicOptions, appId, brokers, store, consumer, producer } =\n      options;\n    this.topic = createTopicOptions ? createTopicOptions.topic : `${appId}.kv`;\n    this.appId = appId;\n    this.createTopicOptions = createTopicOptions;\n\n    this.store = new Store(`db/${appId}`, { cache: true, ...store });\n    this.store.on(\"change\", (ev) => this.handleStoreChange(ev));\n\n    const brokerList = Array.isArray(brokers)\n      ? brokers.join(\",\")\n      : \"localhost:19092\";\n\n    this.consumer = new KafkaConsumer(\n      {\n        \"group.id\": \"kv\",\n        \"bootstrap.servers\": brokerList,\n        \"enable.auto.commit\": false,\n        \"enable.auto.offset.store\": false,\n        ...consumer?.global,\n      },\n      { \"auto.offset.reset\": \"beginning\", ...(consumer?.topic || {}) }\n    );\n\n    this.producer = new Producer(\n      {\n        \"bootstrap.servers\": brokerList,\n        ...producer?.global,\n      },\n      { ...producer?.topic }\n    );\n    this.producer.setPollInterval(10);\n  }\n\n  private handleStoreChange(ev: {\n    op: string;\n    bucket: string;\n    id: string;\n    value: string | Buffer;\n    ttl?: string;\n  }) {\n    const { op, bucket, id, value, ttl } = ev;\n    // console.log(value, JSON.parse(value as string));\n\n    // Construct headers array\n    const headers = [];\n    if (op) headers.push({ op });\n    if (bucket) headers.push({ bucket });\n    if (ttl) headers.push({ ttl });\n\n    const messageValue =\n      op === \"remove\"\n        ? null\n        : Buffer.isBuffer(value)\n        ? value\n        : Buffer.from(value);\n    try {\n      this.producer.produce(\n        this.topic,\n        null,\n        messageValue,\n        id,\n        Date.now(),\n        null,\n        headers\n      );\n    } catch (err: unknown) {\n      const error = err as LibrdKafkaError;\n\n      if (CODES.ERRORS.ERR__QUEUE_FULL === error.code) {\n        console.log(\"Queue full, re-buffering message\");\n        this.producer.poll();\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  private queryWatermark(partition: number): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.consumer.queryWatermarkOffsets(\n        this.topic,\n        partition,\n        5000,\n        (err, offsets) => {\n          if (err) return reject(err);\n          console.log(\"queryWatermarkOffsets\", { partition, offsets });\n          this.watermarks.set(partition, Number(offsets.highOffset));\n          this.topicOffsets.set(partition, -1);\n          resolve();\n        }\n      );\n    });\n  }\n\n  protected async setupPartitionStatus(assignments: Assignment[]) {\n    await Promise.all(\n      assignments.map(({ partition }) => this.queryWatermark(partition))\n    );\n    console.log(\"Partition status initialized:\", this.watermarks);\n  }\n\n  async start() {\n    this.consumer.setDefaultConsumeTimeout(1000);\n    this.consumer.connect();\n    this.producer.connect();\n\n    await Promise.all([\n      once(this.consumer, \"ready\"),\n      once(this.producer, \"ready\"),\n    ]);\n    const admin = AdminClient.createFrom(this.consumer);\n\n    admin.createTopic(\n      {\n        num_partitions: 5,\n        replication_factor: 3,\n        config: {\n          \"segment.ms\": \"300000\",\n          \"segment.bytes\": \"102400\",\n          \"cleanup.policy\": \"compact\",\n        },\n        ...{ ...this.createTopicOptions, topic: this.topic },\n      },\n      async (err) => {\n        if (err && err.code !== CODES.ERRORS.ERR_TOPIC_ALREADY_EXISTS) {\n          throw err;\n        }\n\n        const metadata = await getMetadata(this.consumer, {});\n        const assignments = getAssigments(metadata, [this.topic]);\n        this.consumer.assign(assignments);\n        await this.setupPartitionStatus(assignments);\n\n        this.consumer.consume();\n        this.consumer.on(\"data\", (message) => this.handleConsumerData(message));\n      }\n    );\n\n    await this.waitUntilCaughtUp();\n  }\n\n  private handleConsumerData(message: Message) {\n    this.topicOffsets.set(message.partition, message.offset);\n\n    const headers = message.headers?.reduce<Record<string, string>>(\n      (obj, h) => {\n        const key = Object.keys(h)[0];\n        obj[key] = h[key].toString();\n        return obj;\n      },\n      {}\n    );\n\n    if (message.key && headers?.bucket && headers?.op) {\n      const kv = this.store.bucket(headers.bucket, { encoding: \"json\" });\n      if (headers.op === \"put\") {\n        kv.put(message.key.toString(), message.value, { quiet: true });\n      } else {\n        kv.remove(message.key.toString(), { quiet: true });\n      }\n    }\n  }\n\n  private waitUntilCaughtUp(): Promise<void> {\n    return new Promise((resolve) => {\n      const interval = setInterval(() => {\n        if (this.hasCaughtUp()) {\n          clearInterval(interval);\n          console.log(\"All partitions caught up. KV is ready.\");\n          this.initialized = true;\n          resolve();\n        }\n      }, 1000);\n    });\n  }\n\n  hasCaughtUp() {\n    return Array.from(this.watermarks.entries()).every(\n      ([partition, watermark]) => {\n        const current = this.topicOffsets.get(partition);\n        return current !== undefined && current >= watermark - 1;\n      }\n    );\n  }\n\n  async stop() {\n    this.consumer.unsubscribe();\n    this.consumer.pause(this.consumer.assignments());\n\n    this.producer.flush(5000, (err: LibrdKafkaError) => {\n      console.log(err);\n      this.producer.disconnect();\n      this.consumer.disconnect();\n    });\n\n    await Promise.all(\n      [this.consumer, this.producer].map((client) =>\n        once(client, \"disconnected\")\n      )\n    );\n  }\n}\n","import {\n  Assignment,\n  KafkaConsumer,\n  Metadata,\n  MetadataOptions,\n  SubscribeTopicList,\n} from \"@confluentinc/kafka-javascript\";\n\nexport function getWatermarkOffsets(\n  consumer: KafkaConsumer,\n  topic: string,\n  partitions: number[],\n  timeout = 1000\n) {\n  const queries = partitions.map((partition) => {\n    return new Promise((resolve, reject) => {\n      consumer.queryWatermarkOffsets(\n        topic,\n        partition,\n        timeout,\n        (err, offsets) => {\n          if (err) {\n            return reject(err);\n          }\n          resolve({ partition, highOffset: offsets.highOffset });\n        }\n      );\n    });\n  });\n\n  return Promise.all(queries);\n}\n\nexport function getTopicsMetadata(\n  metadata: Metadata,\n  topics: SubscribeTopicList\n) {\n  return metadata.topics.filter((metaTopic) => {\n    return topics.some((topicFilter) => {\n      if (typeof topicFilter === \"string\") {\n        return metaTopic.name === topicFilter;\n      } else if (topicFilter instanceof RegExp) {\n        return topicFilter.test(metaTopic.name);\n      }\n      return false;\n    });\n  });\n}\n\nexport function getMetadata(\n  consumer: KafkaConsumer,\n  options: MetadataOptions\n): Promise<Metadata> {\n  return new Promise((resolve, reject) =>\n    consumer.getMetadata(options, (err, metadata) =>\n      err ? reject(err) : resolve(metadata)\n    )\n  );\n}\n\nexport function getAssigments(\n  metadata: Metadata,\n  topics: SubscribeTopicList\n): Assignment[] {\n  const assigments = getTopicsMetadata(metadata, topics).flatMap((metaTopic) =>\n    metaTopic.partitions.map((partition) => ({\n      topic: metaTopic.name,\n      partition: partition.id,\n      offset: 0, // Change this offset if you want to start elsewhere\n    }))\n  );\n\n  return assigments;\n}\n"],"mappings":"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","names":["KafkaConsumer","Producer","AdminClient","CODES","Buffer","Store","once","getTopicsMetadata","metadata","topics","metaTopic","topicFilter","getMetadata","consumer","options","resolve","reject","err","getAssigments","partition","Bucketsd","options","createTopicOptions","appId","brokers","store","consumer","producer","Store","ev","brokerList","KafkaConsumer","Producer","op","bucket","id","value","ttl","headers","messageValue","Buffer","err","error","CODES","partition","resolve","reject","offsets","assignments","once","AdminClient","metadata","getMetadata","getAssigments","message","obj","h","key","kv","interval","watermark","current","client"]}